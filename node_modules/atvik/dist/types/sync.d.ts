import { SubscriptionHandle } from './handle';
import { Listener } from './listener';
import { Subscribable } from './subscribable';
/**
 * An event that fires its listeners in a synchronous fashion.
 */
export declare class Event<Parent, Args extends any[] = []> {
    /**
     * Public Subscribable that can safely be shared with consumers that should
     * be able to listen for events.
     */
    readonly subscribable: Subscribable<Parent, Args>;
    /**
     * Parent of this handler, used to apply the correct this to event listeners.
     */
    private readonly parent;
    /**
     * Listener(s) that have been attached to this event handler.
     */
    private registeredListeners?;
    /**
     * Monitor that will be notified on any listener change.
     */
    private monitor?;
    /**
     * Create a new event.
     *
     * @param parent
     *   the parent that will be passed to listener as their `this`
     */
    constructor(parent: Parent);
    /**
     * Emit this event. This will invoke all of the listeners with the passed
     * arguments.
     *
     * @param args
     */
    emit(...args: Args): void;
    /**
     * Subscribe to this event using the given listener. The listener will
     * be invoked any time the event is emitted. The returned handle can be
     * used to unsubscribe.
     *
     * @param listener
     */
    subscribe(listener: Listener<Parent, Args>): SubscriptionHandle;
    /**
     * Unsubscribe a listener from this handler. The specified listener will
     * no longer be invoked when the event is emitted.
     *
     * @param listener
     */
    unsubscribe(listener: Listener<Parent, Args>): boolean;
    /**
     * Get a promise that will resolve the first time this event is fired
     * after this call.
     */
    once(): Promise<Args>;
    /**
     * Get if there are any listeners available.
     */
    readonly hasListeners: boolean;
    /**
     * Get a copy of the listeners as an array.
     */
    readonly listeners: (Listener<Parent, Args> | undefined)[];
    /**
     * Monitor for changes to listeners. Only a single monitor is supported at
     * a single time. This is intended to be used to react to if listeners are
     * currently registered. This can be used for things such as only listening
     * to events from other objects when this event is active.
     *
     * @param monitor
     */
    monitorListeners(monitor: (event: this) => void): void;
    /**
     * Stop monitoring for listener changes.
     */
    removeMonitor(): void;
}
//# sourceMappingURL=sync.d.ts.map