"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An event that fires its listeners in a synchronous fashion.
 */
var Event = /** @class */ (function () {
    /**
     * Create a new event.
     *
     * @param parent
     *   the parent that will be passed to listener as their `this`
     */
    function Event(parent) {
        var _this = this;
        this.parent = parent;
        var subscribable = function (listener) { return _this.subscribe(listener); };
        subscribable.subscribe = subscribable;
        subscribable.unsubscribe = function (listener) { return _this.unsubscribe(listener); };
        subscribable.once = function () { return _this.once(); };
        this.subscribable = subscribable;
    }
    /**
     * Emit this event. This will invoke all of the listeners with the passed
     * arguments.
     *
     * @param args
     */
    Event.prototype.emit = function () {
        var e_1, _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (Array.isArray(this.registeredListeners)) {
            try {
                /*
                 * Array is present, iterate over array and invoke all of the
                 * listeners.
                 */
                for (var _b = __values(this.registeredListeners), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var listener = _c.value;
                    listener.apply(this.parent, args);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else if (this.registeredListeners) {
            /*
             * Single listener is present, simply invoke the listener.
             */
            this.registeredListeners.apply(this.parent, args);
        }
    };
    /**
     * Subscribe to this event using the given listener. The listener will
     * be invoked any time the event is emitted. The returned handle can be
     * used to unsubscribe.
     *
     * @param listener
     */
    Event.prototype.subscribe = function (listener) {
        if (Array.isArray(this.registeredListeners)) {
            // Listeners is already an array, create a copy with the new listener appended
            this.registeredListeners = __spread(this.registeredListeners, [listener]);
        }
        else if (this.registeredListeners) {
            this.registeredListeners = [this.registeredListeners, listener];
        }
        else {
            this.registeredListeners = listener;
        }
        if (this.monitor) {
            // Trigger the monitor if available
            this.monitor(this);
        }
        var self = this;
        return {
            unsubscribe: function () {
                return self.unsubscribe(listener);
            }
        };
    };
    /**
     * Unsubscribe a listener from this handler. The specified listener will
     * no longer be invoked when the event is emitted.
     *
     * @param listener
     */
    Event.prototype.unsubscribe = function (listener) {
        if (Array.isArray(this.registeredListeners)) {
            /*
             * Array has been allocated, find the index of the listener and
             * then remove it from the array.
             */
            var idx = this.registeredListeners.indexOf(listener);
            if (idx < 0)
                return false;
            // Copy-on-write for deletions
            var listeners = __spread(this.registeredListeners);
            listeners.splice(idx);
            this.registeredListeners = listener;
            /*
             * If the array is empty, remove it. Otherwise at this point the
             * array has already been allocated so keep the array in case a
             * subscription happens again.
             */
            if (this.registeredListeners.length === 0) {
                this.registeredListeners = undefined;
            }
            if (this.monitor) {
                // Trigger the monitor if available
                this.monitor(this);
            }
            return true;
        }
        else if (this.registeredListeners === listener) {
            /*
             * Single listener is present and its the current match. Reset
             * listeners property.
             */
            this.registeredListeners = undefined;
            if (this.monitor) {
                // Trigger the monitor if available
                this.monitor(this);
            }
            return true;
        }
        // Listener is not active
        return false;
    };
    /**
     * Get a promise that will resolve the first time this event is fired
     * after this call.
     */
    Event.prototype.once = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var listener = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                _this.unsubscribe(listener);
                resolve(args);
            };
            _this.subscribe(listener);
        });
    };
    Object.defineProperty(Event.prototype, "hasListeners", {
        /**
         * Get if there are any listeners available.
         */
        get: function () {
            return this.registeredListeners !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "listeners", {
        /**
         * Get a copy of the listeners as an array.
         */
        get: function () {
            if (Array.isArray(this.registeredListeners)) {
                return this.registeredListeners.slice(0);
            }
            else {
                return [this.registeredListeners];
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Monitor for changes to listeners. Only a single monitor is supported at
     * a single time. This is intended to be used to react to if listeners are
     * currently registered. This can be used for things such as only listening
     * to events from other objects when this event is active.
     *
     * @param monitor
     */
    Event.prototype.monitorListeners = function (monitor) {
        if (this.monitor) {
            throw new Error('A monitor is already registered, call removeMonitor before registering a new monitor');
        }
        this.monitor = monitor;
    };
    /**
     * Stop monitoring for listener changes.
     */
    Event.prototype.removeMonitor = function () {
        this.monitor = undefined;
    };
    return Event;
}());
exports.Event = Event;
//# sourceMappingURL=sync.js.map