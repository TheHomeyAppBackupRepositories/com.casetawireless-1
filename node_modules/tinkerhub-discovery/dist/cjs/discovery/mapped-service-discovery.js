"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var internal_1 = require("./internal");
/**
 * Provides mapping of any discovery instance.
 */
var MappedDiscovery = /** @class */ (function (_super) {
    __extends(MappedDiscovery, _super);
    function MappedDiscovery(parent, mapper) {
        var _this = _super.call(this, 'mapped', parent) || this;
        _this.mappedServices = new Map();
        _this.mapper = mapper;
        return _this;
    }
    MappedDiscovery.prototype.handleParentServiceAvailable = function (service) {
        var _this = this;
        var current = this.mappedServices.get(service.id);
        if (current) {
            /*
             * This service is currently registered. As available events are
             * only emitted after an unavailable event has occurred this is
             * an invalid state. Log and then skip handling the event.
             */
            this.debug('Warning: Received available event for already existing service', service.id);
            return;
        }
        var promise = Promise.resolve(this.mapper.create(service))
            .then(function (mappedService) {
            /*
             * The service has been mapped, check that the registration is
             * still valid and in that case register it.
             */
            var reg = _this.mappedServices.get(service.id);
            if (!reg || reg.promise !== promise)
                return;
            // Reset the promise to allow it to be garbage collected
            reg.promise = undefined;
            if (mappedService) {
                // Mapping returned an instance, make the service available
                reg.service = mappedService;
                _this.updateService(mappedService);
            }
        })
            .catch(function (err) {
            _this.logAndEmitError(err, 'An error occurred during mapping of ' + service.id + ':');
        });
        this.mappedServices.set(service.id, {
            promise: promise
        });
    };
    MappedDiscovery.prototype.handleParentServiceUnavailable = function (service) {
        var current = this.mappedServices.get(service.id);
        if (!current)
            return;
        // Delete the registration
        this.mappedServices.delete(service.id);
        if (current.service) {
            var mappedId = current.service.id;
            // If the service was available remove it
            this.removeService(mappedId);
        }
    };
    MappedDiscovery.prototype.handleParentServiceUpdate = function (service, previousService) {
        var _this = this;
        var current = this.mappedServices.get(service.id);
        if (!current) {
            // No current registration, emit a warning and return
            this.debug('Warning: Received an update for a service that was not available:', service.id);
            return;
        }
        if (current.service && this.mapper.update) {
            // Service is available and mapper supports updates
            if (current.promise) {
                // This service is currently being mapped somehow
                this.debug('Update received for', service.id, ' while service was being updated, replacing with new update');
            }
            var mappedId_1 = current.service.id;
            var promise_1 = Promise.resolve(this.mapper.update({
                service: service,
                previousService: previousService,
                previousMappedService: current.service
            }))
                .then(function (mappedService) {
                /*
                * The service has been updated, check that the registration
                * is still valid and in that case perform the update.
                */
                var reg = _this.mappedServices.get(service.id);
                if (!reg || reg.promise !== promise_1)
                    return;
                // Reset the promise to allow it to be garbage collected
                reg.promise = undefined;
                if (mappedService && mappedService) {
                    // Mapping returned an instance, update or make the service available
                    reg.service = mappedService;
                    if (mappedService.id !== mappedId_1) {
                        // The identifier has changed, remove the old service
                        _this.removeService(mappedId_1);
                    }
                    _this.updateService(mappedService);
                }
                else {
                    // No instance returned, so the service should no longer be available
                    reg.service = undefined;
                    _this.removeService(mappedId_1);
                }
            })
                .catch(function (err) {
                _this.logAndEmitError(err, 'An error occurred during update of ' + service.id + ':');
            });
            current.promise = promise_1;
        }
        else if (!current.service) {
            // No service is available, perform a regular mapping
            var promise_2 = Promise.resolve(this.mapper.create(service))
                .then(function (mappedService) {
                /*
                * The service has been mapped, check that the registration is
                * still valid and in that case register it.
                */
                var reg = _this.mappedServices.get(service.id);
                if (!reg || reg.promise !== promise_2)
                    return;
                // Reset the promise to allow it to be garbage collected
                reg.promise = undefined;
                if (mappedService) {
                    // Mapping returned an instance, make the service available
                    reg.service = mappedService;
                    _this.updateService(mappedService);
                }
            })
                .catch(function (err) {
                _this.logAndEmitError(err, 'An error occurred during mapping of ' + service.id + ':');
            });
            current.promise = promise_2;
        }
    };
    MappedDiscovery.prototype.updateService = function (service) {
        var updated = _super.prototype.updateService.call(this, service);
        if (updated) {
            this.destroyService(updated);
        }
        return updated;
    };
    MappedDiscovery.prototype.removeService = function (service) {
        var removed = _super.prototype.removeService.call(this, service);
        if (removed) {
            this.destroyService(removed);
        }
        return removed;
    };
    MappedDiscovery.prototype.destroyService = function (service) {
        var _this = this;
        if (!this.mapper.destroy)
            return;
        // If the mapper supports destruction call it and log any errors
        var id = service.id;
        Promise.resolve(this.mapper.destroy(service))
            .catch(function (err) {
            _this.logAndEmitError(err, 'An error occurred during destruction of mapped service with id ' + id + ':');
        });
    };
    return MappedDiscovery;
}(internal_1.LayeredServiceDiscovery));
exports.MappedDiscovery = MappedDiscovery;
//# sourceMappingURL=mapped-service-discovery.js.map