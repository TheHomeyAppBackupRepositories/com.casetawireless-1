"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var internal_1 = require("./internal");
/**
 * Provides filtering of any discovery instance.
 */
var FilteredServiceDiscovery = /** @class */ (function (_super) {
    __extends(FilteredServiceDiscovery, _super);
    function FilteredServiceDiscovery(parent, predicate) {
        var _this = _super.call(this, 'filtered', parent) || this;
        _this.predicate = predicate;
        return _this;
    }
    Object.defineProperty(FilteredServiceDiscovery.prototype, "services", {
        /**
         * Get all of the available services.
         */
        get: function () {
            return this.parent.services
                .filter(this.predicate);
        },
        enumerable: true,
        configurable: true
    });
    FilteredServiceDiscovery.prototype.get = function (id) {
        var service = this.parent.get(id);
        if (service && this.predicate(service)) {
            return service;
        }
        return null;
    };
    FilteredServiceDiscovery.prototype.handleParentServiceAvailable = function (service) {
        if (this.predicate(service)) {
            this.updateService(service);
        }
    };
    FilteredServiceDiscovery.prototype.handleParentServiceUnavailable = function (service) {
        this.removeService(service);
    };
    FilteredServiceDiscovery.prototype.handleParentServiceUpdate = function (service) {
        if (this.predicate(service)) {
            /*
             * Either the service still matches or it now matches. Make it
             * available in this discovery.
             */
            this.updateService(service);
        }
        else {
            /*
             * Remove the service is if it no longer matches.
             */
            this.removeService(service.id);
        }
    };
    return FilteredServiceDiscovery;
}(internal_1.LayeredServiceDiscovery));
exports.FilteredServiceDiscovery = FilteredServiceDiscovery;
//# sourceMappingURL=filtered-service-discovery.js.map