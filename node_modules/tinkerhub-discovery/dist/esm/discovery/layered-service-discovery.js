var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { BasicServiceDiscovery } from './internal';
/**
 * Abstract discovery for implementing layers, such as filtering and mapping.
 */
export class LayeredServiceDiscovery extends BasicServiceDiscovery {
    constructor(type, parent) {
        super(type);
        this.parent = parent;
        this.handleParentServiceAvailable = this.handleParentServiceAvailable.bind(this);
        this.handleParentServiceUnavailable = this.handleParentServiceUnavailable.bind(this);
        this.handleParentServiceUpdate = this.handleParentServiceUpdate.bind(this);
        this.destroy = this.destroy.bind(this);
        this.parent.onAvailable(this.handleParentServiceAvailable);
        this.parent.onUnavailable(this.handleParentServiceUnavailable);
        this.parent.onUpdate(this.handleParentServiceUpdate);
        // Bind so that this layer id destroyed when the parent is
        this.parent.onDestroy(this.destroy);
        // Make the current services available
        for (const service of parent.services) {
            this.handleParentServiceAvailable(service);
        }
    }
    /**
     * Release this discovery, it will no longer receive any service updates.
     */
    release() {
        const _super = Object.create(null, {
            destroy: { get: () => super.destroy }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.destroyed)
                return;
            this.parent.onAvailable.unsubscribe(this.handleParentServiceAvailable);
            this.parent.onUnavailable.unsubscribe(this.handleParentServiceUnavailable);
            this.parent.onUpdate.unsubscribe(this.handleParentServiceUpdate);
            this.parent.onDestroy.unsubscribe(this.destroy);
            yield _super.destroy.call(this);
        });
    }
    /**
     * Destroy this discovery and its parent.
     */
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.destroyed)
                return;
            // Destroy the parent
            yield this.parent.destroy();
            // Release our resources.
            yield this.release();
        });
    }
}
//# sourceMappingURL=layered-service-discovery.js.map