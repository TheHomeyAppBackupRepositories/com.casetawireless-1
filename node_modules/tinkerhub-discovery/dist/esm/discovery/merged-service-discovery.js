var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { BasicServiceDiscovery } from './internal';
/**
 * Merge services from several discoveries.
 */
export class MergedServiceDiscovery extends BasicServiceDiscovery {
    constructor(discoveries) {
        super('combined');
        this.combinedServiceData = new Map();
        this.instances = [];
        for (const discovery of discoveries) {
            const handleAvailableOrUpdate = (service) => this.handleAvailableOrUpdate(discovery, service);
            const handleUnavailable = (service) => this.handleUnavailable(discovery, service);
            // Create the instance and register the events
            const instance = {
                discovery: discovery,
                handles: [
                    discovery.onAvailable(handleAvailableOrUpdate),
                    discovery.onUpdate(handleAvailableOrUpdate),
                    discovery.onUnavailable(handleUnavailable),
                    discovery.onError(this.handleError)
                ]
            };
            this.instances.push(instance);
        }
    }
    release() {
        const _super = Object.create(null, {
            destroy: { get: () => super.destroy }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.destroyed) {
                // Release all of the events for every instance
                for (const instance of this.instances) {
                    for (const handle of instance.handles) {
                        handle.unsubscribe();
                    }
                }
            }
            yield _super.destroy.call(this);
        });
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.destroyed) {
                // Destroy all of the instances
                for (const instance of this.instances) {
                    yield instance.discovery.destroy();
                }
            }
            yield this.release();
        });
    }
    handleError(error) {
        super.logAndEmitError(error);
    }
    handleAvailableOrUpdate(discovery, service) {
        let data = this.combinedServiceData.get(service.id);
        if (data) {
            // A service with this identifier is currently available
            const discoveryIndex = data.discoveries.indexOf(discovery);
            if (discoveryIndex < 0) {
                // Service is new for this discovery
                data.services.push(service);
                data.discoveries.push(discovery);
            }
            else {
                // Update the current service for the discovery
                data.services[discoveryIndex] = service;
            }
            if (discoveryIndex === 0 || data.discoveries.length === 1) {
                // If the service is either new or was the first service, update it
                this.updateService(service);
            }
        }
        else {
            // New service, create data and register it
            data = {
                services: [service],
                discoveries: [discovery]
            };
            this.combinedServiceData.set(service.id, data);
            // Register this as the service
            this.updateService(service);
        }
    }
    handleUnavailable(discovery, service) {
        const data = this.combinedServiceData.get(service.id);
        if (!data) {
            // No services registered for the id
            return;
        }
        const discoveryIndex = data.discoveries.indexOf(discovery);
        if (discoveryIndex < 0) {
            // Discovery does not actually have a service registered
            return;
        }
        data.discoveries.splice(discoveryIndex, 1);
        data.services.splice(discoveryIndex, 1);
        if (discoveryIndex !== 0) {
            // This was not the first service, no need to update service
            return;
        }
        if (data.discoveries.length === 0) {
            // Remove the service as it is no longer available
            this.removeService(service);
            this.combinedServiceData.delete(service.id);
        }
        else {
            // Update to the service that is now the first available
            this.updateService(data.services[0]);
        }
    }
}
//# sourceMappingURL=merged-service-discovery.js.map