"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var timer_wheel_1 = require("./timer-wheel");
/**
 * Variant of TimerWheel that runs actions.
 */
var ActionTimerWheel = /** @class */ (function () {
    function ActionTimerWheel() {
        this.timerWheel = new timer_wheel_1.TimerWheel();
    }
    /**
     * Advance the wheel, running all actions whose delay has passed.
     */
    ActionTimerWheel.prototype.advance = function () {
        var e_1, _a;
        var expired = this.timerWheel.advance();
        try {
            for (var expired_1 = __values(expired), expired_1_1 = expired_1.next(); !expired_1_1.done; expired_1_1 = expired_1.next()) {
                var action = expired_1_1.value;
                action();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (expired_1_1 && !expired_1_1.done && (_a = expired_1.return)) _a.call(expired_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Schedule an action that should be run after a certain delay.
     *
     * @param action
     *   action to run
     * @param delayInMs
     *   minimum delay before the action is run
     */
    ActionTimerWheel.prototype.schedule = function (action, delayInMs) {
        return this.timerWheel.schedule(action, delayInMs);
    };
    return ActionTimerWheel;
}());
exports.ActionTimerWheel = ActionTimerWheel;
//# sourceMappingURL=action-timer-wheel.js.map