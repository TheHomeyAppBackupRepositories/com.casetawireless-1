import { TimerNode } from './timer-node';
import { TimerHandle } from './handle';
/**
 * A timer wheel for efficiently managing a large amount of time based items.
 *
 * Items can be scheduled to be expired using a certain delay in milliseconds:
 *
 * ```typescript
 * const wheel = new TimerWheel<any>();
 * wheel.schedule('testData', 200);
 * ```
 *
 * The wheel must then be advanced to expire things:
 *
 * ```javascript
 * const expired = wheel.advance();
 * ```
 *
 * This allows users of this class to control when objects are expired. This
 * design allows for implementations of such things as expiring cached items
 * just before a get instead of continuously evaluating.
 *
 * This wheel will schedule items to be expired several times. If you need to
 * reschedule unique items, use `ReschedulingTimerWheel`.
 *
 * Stores items in layers that are circular buffers that represent a time span.
 * This allows for efficiently figuring out what actions need to invoked
 * whenever the wheel is advanced.
 *
 * This implementation takes some extra care to work with Number as they are
 * actually doubles and shifting turns them into 32-bit ints. To represent
 * time we need more than 32-bits so to fully support things this implementation
 * uses a base which is removed from all of the numbers to make them fit into
 * 32-bits.
 *
 * Based on the implementation in the caching library Transitory, which in turn
 * is based on an idea by Ben Manes implemented in Caffeine.
 */
export declare class TimerWheel<T> {
    private time;
    private readonly base;
    private readonly layers;
    constructor();
    /**
     * Get the local time of this wheel.
     */
    private readonly localTime;
    private findBucket;
    /**
     * Advance the wheel, returning all expired items.
     *
     * @param localTime
     *   optional timestamp used for things such as testing. Represents the
     *   number of milliseconds passed since this wheel was created.
     */
    advance(localTime?: number): T[];
    /**
     * Schedule the data to be expired after the given delay.
     */
    schedule(data: T, delayInMs: number): TimerHandle;
    protected scheduleNode(node: TimerNode<T>): TimerHandle;
    protected expireNode(node: TimerNode<T>): void;
}
//# sourceMappingURL=timer-wheel.d.ts.map