"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var multicast_dns_1 = __importDefault(require("multicast-dns"));
var abstract_transport_1 = require("./abstract-transport");
var records_1 = require("../records");
var query_1 = require("../query");
var response_1 = require("../response");
var MulticastDNSTransport = /** @class */ (function (_super) {
    __extends(MulticastDNSTransport, _super);
    function MulticastDNSTransport(options) {
        var _this = _super.call(this, options) || this;
        _this.mdns = multicast_dns_1.default();
        _this.mdns.on('error', function (err) {
            _this.onError(err);
        });
        _this.mdns.on('response', function (packet, rinfo) {
            var response = new response_1.MDNSResponse(_this.fromTransportsRecords(packet.answers || []), _this.fromTransportsRecords(packet.additionals || []));
            _this.onResponse(response);
        });
        _this.mdns.on('query', function (packet, rinfo) {
            var response = new query_1.MDNSQuery(packet.questions || [], _this.fromTransportsRecords(packet.answers || []), _this.fromTransportsRecords(packet.additionals || []));
            _this.onQuery(response);
        });
        return _this;
    }
    MulticastDNSTransport.prototype.fromTransportsRecords = function (records) {
        var e_1, _a;
        var result = [];
        try {
            for (var records_2 = __values(records), records_2_1 = records_2.next(); !records_2_1.done; records_2_1 = records_2.next()) {
                var r = records_2_1.value;
                result.push(this.mapRecord(fromTransportRecord(r)));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (records_2_1 && !records_2_1.done && (_a = records_2.return)) _a.call(records_2);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    };
    MulticastDNSTransport.prototype.query = function (query) {
        var _this = this;
        var packet = {
            questions: query.questions.map(function (q) { return ({
                name: q.name,
                type: q.type,
                class: q.class
            }); }),
            answers: query.answers.map(toTransportRecord),
            additionals: query.additionals.map(toTransportRecord),
        };
        return new Promise(function (resolve, reject) {
            return _this.mdns.query(packet, function (err) {
                if (err) {
                    reject(err);
                }
                resolve();
            });
        });
    };
    MulticastDNSTransport.prototype.respond = function (response) {
        var _this = this;
        var packet = {
            answers: response.answers.map(toTransportRecord),
            additionals: response.additionals.map(toTransportRecord),
        };
        return new Promise(function (resolve, reject) {
            return _this.mdns.respond(packet, function (err) {
                if (err) {
                    reject(err);
                }
                resolve();
            });
        });
    };
    MulticastDNSTransport.prototype.destroy = function () {
        this.mdns.destroy();
    };
    return MulticastDNSTransport;
}(abstract_transport_1.AbstractTransport));
exports.MulticastDNSTransport = MulticastDNSTransport;
function toTransportRecord(record) {
    var data;
    if (record instanceof records_1.ARecord) {
        data = record.ip;
    }
    else if (record instanceof records_1.AAAARecord) {
        data = record.ip;
    }
    else if (record instanceof records_1.TXTRecord) {
        data = record.binaryData;
    }
    else if (record instanceof records_1.PTRRecord) {
        data = record.hostname;
    }
    else if (record instanceof records_1.SRVRecord) {
        data = {
            target: record.target,
            port: record.port
        };
    }
    else if (record instanceof records_1.UnknownRecord) {
        data = record.data;
    }
    else {
        data = undefined;
    }
    return {
        type: record.type,
        name: record.name,
        ttl: record.ttl,
        class: record.class,
        flush: record.flush,
        data: data
    };
}
function fromTransportRecord(answer) {
    switch (answer.type) {
        case 'A':
            return new records_1.ARecord(Object.assign(answer, {
                ip: answer.data
            }));
        case 'AAAA':
            return new records_1.AAAARecord(Object.assign(answer, {
                ip: answer.data
            }));
        case 'TXT':
            return new records_1.TXTRecord(Object.assign(answer, {
                data: answer.data,
                decode: true
            }));
        case 'SRV':
            return new records_1.SRVRecord(Object.assign(answer, {
                target: answer.data.target,
                port: answer.data.port
            }));
        case 'PTR':
            return new records_1.PTRRecord(Object.assign(answer, {
                hostname: answer.data
            }));
        default:
            return new records_1.UnknownRecord(answer);
    }
}
exports.fromTransportRecord = fromTransportRecord;
//# sourceMappingURL=multicast-dns-transport.js.map