"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tinkerhub_discovery_1 = require("tinkerhub-discovery");
var multicast_dns_service_types_1 = require("multicast-dns-service-types");
var manager_1 = require("../manager");
var record_handle_1 = require("./record-handle");
var record_array_1 = require("./record-array");
var ttl_refresh_helper_1 = require("./ttl-refresh-helper");
// Minimum delay in ms before starting another search
var SEARCH_MIN_DELAY = 1000;
// Maximum delay in ms between searches
var SEARCH_MAX_DELAY = 60 * 60 * 1000;
// Factor to multiply delay with after every search
var SEARCH_DELAY_FACTOR = 3;
/**
 * Discovery that finds services exposed over Multicast DNS on the local
 * network.
 */
// TODO: Expose type, protocol and subtypes?
var MDNSServiceDiscovery = /** @class */ (function (_super) {
    __extends(MDNSServiceDiscovery, _super);
    function MDNSServiceDiscovery(options) {
        var _this = _super.call(this, 'mdns') || this;
        _this.serviceData = new Map();
        _this.queuedRefreshes = new Set();
        _this.ttlRefreshHelper = new ttl_refresh_helper_1.TTLRefreshHelper(function () { return _this.search(false); });
        _this.searchName = multicast_dns_service_types_1.stringify(options.type, options.protocol || 'tcp') + '.local';
        _this.normalizedSearchName = normalizeName(_this.searchName);
        _this.mdns = manager_1.createMDNS();
        _this.mdns.onResponse(_this.handleResponse.bind(_this));
        _this.mdns.onQuery(_this.handleQuery.bind(_this));
        // Select an initial search delay between 20 and 120 ms
        var initialDelay = 20 + Math.random() * 100;
        // Queue the initial search
        _this.searchTime = 0;
        _this.searchLastInvoke = 0;
        _this.searchTimeout = setTimeout(function () { return _this.search(true); }, initialDelay);
        return _this;
    }
    MDNSServiceDiscovery.prototype.destroy = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        clearTimeout(this.searchTimeout);
                        this.ttlRefreshHelper.destroy();
                        this.mdns.destroy();
                        return [4 /*yield*/, _super.prototype.destroy.call(this)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Perform a search for services on the network. This function will send
     * a query out which will cause responders to send back their records.
     *
     * Search is called:
     * 1) Periodically, with increasing query times, up to an hour of delay
     * 2) When records are nearing expiration
     */
    MDNSServiceDiscovery.prototype.search = function (periodical) {
        var _this = this;
        var now = Date.now();
        if (periodical) {
            this.debug('Searching for services on schedule');
        }
        else {
            // Check that we're not performing a non-periodical search too quickly
            if (now - this.searchLastInvoke < SEARCH_MIN_DELAY)
                return;
            this.debug('Searching for services due to near-end TTL');
        }
        this.searchLastInvoke = now;
        var query = new manager_1.MDNSQuery([
            {
                type: 'PTR',
                name: this.searchName
            }
        ]);
        this.mdns.query(query)
            .catch(function (err) { return _this.logAndEmitError(err, 'Caught error during search'); });
        if (periodical) {
            // Periodical searches increase the delay time
            if (this.searchTime === 0) {
                // Next search is for the minimum delay
                this.searchTime = SEARCH_MIN_DELAY;
            }
            else {
                // Increase the delay until max is reached
                this.searchTime = Math.min(this.searchTime * SEARCH_DELAY_FACTOR, SEARCH_MAX_DELAY);
            }
        }
        // Reschedule searching
        this.rescheduleSearch();
    };
    /**
     * Reschedule when the search is next performed.
     */
    MDNSServiceDiscovery.prototype.rescheduleSearch = function () {
        var _this = this;
        clearTimeout(this.searchTimeout);
        this.searchTimeout = setTimeout(function () { return _this.search(true); }, this.searchTime);
    };
    /**
     * Handle incoming queries. Used to reschedule searches if another client
     * on the network is seen querying for the same service as us.
     *
     * @param query
     */
    MDNSServiceDiscovery.prototype.handleQuery = function (query) {
        if (this.isSameQuery(query)) {
            /*
             * This query is the same we would send, reschedule our next
             * search if our last search was more than 500 ms ago. This
             * avoid us rescheduling after our own query.
             */
            if (Date.now() - this.searchLastInvoke > 500) {
                this.debug('Rescheduling search due to incoming query');
                this.rescheduleSearch();
            }
        }
    };
    MDNSServiceDiscovery.prototype.isSameQuery = function (query) {
        var e_1, _a, e_2, _b;
        try {
            for (var _c = __values(query.questions), _d = _c.next(); !_d.done; _d = _c.next()) {
                var q = _d.value;
                if (q.type === 'PTR' && normalizeName(q.name) === this.normalizedSearchName) {
                    // Check that all the answers have been seen by us
                    if (query.answers) {
                        var _loop_1 = function (answer) {
                            var record = this_1.mdns.find(function (item) { return item.isEqual(answer); });
                            if (!record) {
                                return { value: false };
                            }
                        };
                        var this_1 = this;
                        try {
                            for (var _e = (e_2 = void 0, __values(query.answers)), _f = _e.next(); !_f.done; _f = _e.next()) {
                                var answer = _f.value;
                                var state_1 = _loop_1(answer);
                                if (typeof state_1 === "object")
                                    return state_1.value;
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                    return true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    };
    MDNSServiceDiscovery.prototype.isMatching = function (PTR) {
        var normalizedRecordName = normalizeName(PTR.name);
        return normalizedRecordName === this.normalizedSearchName;
    };
    MDNSServiceDiscovery.prototype.handleResponse = function (response) {
        var e_3, _a;
        var _this = this;
        var _loop_2 = function (record) {
            if (record instanceof manager_1.PTRRecord && this_2.isMatching(record)) {
                /*
                * This PTR is what we're looking for. Queue a refresh of the
                * service.
                */
                if (this_2.queuedRefreshes.has(record.hostname)) {
                    return "continue";
                }
                this_2.queuedRefreshes.add(record.hostname);
                setTimeout(function () { return _this.refreshService(record.hostname); }, 500);
            }
        };
        var this_2 = this;
        try {
            for (var _b = __values(response.mergedRecords), _c = _b.next(); !_c.done; _c = _b.next()) {
                var record = _c.value;
                _loop_2(record);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    MDNSServiceDiscovery.prototype.refreshService = function (name) {
        var e_4, _a, e_5, _b, e_6, _c;
        var _this = this;
        this.debug('Refreshing service', name);
        // Remove from the refresh queue
        this.queuedRefreshes.delete(name);
        var data = this.serviceData.get(name);
        var PTR = this.mdns.find(function (record) { return record instanceof manager_1.PTRRecord && record.hostname === name; });
        if (!data) {
            if (!PTR) {
                this.debug('Requested refresh of non-existent service', name, 'without an initial PTR record');
                return;
            }
            var refreshThis_1 = function () {
                if (_this.queuedRefreshes.has(name))
                    return;
                _this.queuedRefreshes.add(name);
                setTimeout(function () { return _this.refreshService(name); }, 500);
            };
            var onSet = function (record) {
                /*
                 * When a record becomes active, listen for it being expired
                 * and add it to the refresh helper.
                 */
                record.onExpire(refreshThis_1);
                _this.ttlRefreshHelper.add(record);
            };
            var onRemove = function (record) {
                // Remove old records from refresh listeners
                record.onExpire.unsubscribe(refreshThis_1);
                _this.ttlRefreshHelper.remove(record);
            };
            data = {
                PTR: new record_handle_1.RecordHandle(onSet, onRemove),
                SRV: new record_handle_1.RecordHandle(onSet, onRemove),
                addressRecords: new record_array_1.RecordArray(refreshThis_1),
                txtRecords: new record_array_1.RecordArray(refreshThis_1)
            };
            data.PTR.update(PTR);
            // Store the service data for next refresh
            this.serviceData.set(name, data);
        }
        else if (PTR) {
            if (data.PTR.record !== PTR) {
                // The PTR record has changed
                this.debug('Updating', name, 'with new PTR');
                data.PTR.update(PTR);
            }
        }
        else {
            // PTR has expired
            this.debug('Removing', name, 'due to no PTR');
            this.invalidateService(name, data);
            return;
        }
        var SRV = this.mdns.find(function (record) { return record instanceof manager_1.SRVRecord && record.name === name; });
        if (SRV) {
            if (data.SRV.record !== SRV) {
                // This is a new SRV record - update our record
                this.debug('Updating', name, 'with new SRV');
                data.SRV.update(SRV);
            }
        }
        else {
            // No SRV - invalidate the service
            this.debug('Removing', name, 'due to no SRV');
            this.invalidateService(name, data);
            return;
        }
        // Collect all of the addresses the service can be reached at
        var port = SRV.port;
        var host = SRV.target;
        var records = this.mdns.findAll(function (record) {
            return (record instanceof manager_1.ARecord || record instanceof manager_1.AAAARecord)
                && record.name === host;
        });
        data.addressRecords.items = records;
        if (records.length === 0) {
            this.debug('Removing', name, 'due to no addresses available');
            this.invalidateService(name, data);
            return;
        }
        var addresses = records
            .map(function (record) { return new tinkerhub_discovery_1.HostAndPort(record.ip, port); })
            .sort(tinkerhub_discovery_1.HostAndPort.compare);
        // Map TXT records into data
        var txtData = new Map();
        var binaryData = [];
        var txtRecords = this.mdns.findAll(function (record) { return record instanceof manager_1.TXTRecord && record.name === name; });
        try {
            for (var txtRecords_1 = __values(txtRecords), txtRecords_1_1 = txtRecords_1.next(); !txtRecords_1_1.done; txtRecords_1_1 = txtRecords_1.next()) {
                var record = txtRecords_1_1.value;
                try {
                    for (var _d = (e_5 = void 0, __values(record.data.entries())), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var _f = __read(_e.value, 2), key = _f[0], value = _f[1];
                        txtData.set(key, value);
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                try {
                    for (var _g = (e_6 = void 0, __values(record.binaryData)), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var buffer = _h.value;
                        binaryData.push(buffer);
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_c = _g.return)) _c.call(_g);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (txtRecords_1_1 && !txtRecords_1_1.done && (_a = txtRecords_1.return)) _a.call(txtRecords_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        // Extract the local name and parse the service
        // TODO: Replace multicast-dns-service-types at some point
        var idx = name.indexOf('.');
        var localName = name.substring(0, idx);
        var parsedService = multicast_dns_service_types_1.parse(name.substring(idx + 1, name.length - 6));
        // Map the final service data and add/update service
        var service = {
            id: name,
            name: localName,
            type: parsedService.name || 'unknown',
            protocol: parsedService.protocol,
            subtypes: parsedService.subtypes || [],
            addresses: addresses,
            data: txtData,
            binaryData: binaryData
        };
        this.updateService(service);
    };
    MDNSServiceDiscovery.prototype.invalidateService = function (name, data) {
        data.PTR.update(null);
        data.SRV.update(null);
        this.removeService(name);
        this.serviceData.delete(name);
    };
    return MDNSServiceDiscovery;
}(tinkerhub_discovery_1.BasicServiceDiscovery));
exports.MDNSServiceDiscovery = MDNSServiceDiscovery;
function normalizeName(n) {
    return n ? n.toLowerCase() : n;
}
//# sourceMappingURL=mdns-discovery.js.map