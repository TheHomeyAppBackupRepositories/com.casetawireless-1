import { AbstractServicePublisher } from 'tinkerhub-discovery';
import { MDNSQuery } from './manager';
import { Protocol } from './protocol';
/**
 * Options that can be used when publishing a service over Multicast DNS.
 */
export interface MDNSServicePublisherOptions {
    /**
     * The name of the service. If this is not specified a randomly generated
     * name will be used.
     */
    name?: string;
    /**
     * Port number of service. This is the port number than a consumer can use
     * to connect to this service.
     */
    port: number;
    /**
     * Type of the service.
     */
    type: string;
    /**
     * Protocol used by the service.
     */
    protocol?: Protocol;
    /**
     * Sub-types of the service.
     */
    subtypes?: [];
    /**
     * Extra data to expose for the service. Useful to expose information about
     * the service, such as a human readable name or a unique identifier.
     */
    data?: Map<string, string | boolean>;
    /**
     * The number of seconds this service should be assumed to be available.
     * Defaults to 75 minutes.
     */
    ttl?: number;
}
/**
 * A service published using Multicast DNS.
 */
export declare class MDNSServicePublisher extends AbstractServicePublisher {
    private mdns;
    readonly qualifiedName: string;
    readonly name: string;
    readonly port: number;
    readonly type: string;
    readonly ttl: number;
    private broadcastTimeout;
    private broadcastTime;
    private broadcastNumber;
    constructor(options: MDNSServicePublisherOptions);
    protected handleQuery(query: MDNSQuery): void;
    /**
     * Go through known services and check if the querier knows about this
     * service.
     *
     * The following must match:
     * 1) The record must be a PTR
     * 2) The name of the record must match our type
     * 3) The hostname must match our qualified name
     * 4) The TTL must be more than half the original value
     *
     * @param answers
     */
    private hasService;
    broadcast(): void;
    private announce;
    destroy(): Promise<void>;
    private sendGoodbye;
}
//# sourceMappingURL=publisher.d.ts.map